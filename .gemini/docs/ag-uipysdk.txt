Directory structure:
‚îî‚îÄ‚îÄ python-sdk/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ LICENSE
    ‚îú‚îÄ‚îÄ pyproject.toml
    ‚îú‚îÄ‚îÄ ag_ui/
    ‚îÇ   ‚îú‚îÄ‚îÄ py.typed
    ‚îÇ   ‚îú‚îÄ‚îÄ core/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ events.py
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.py
    ‚îÇ   ‚îî‚îÄ‚îÄ encoder/
    ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ       ‚îî‚îÄ‚îÄ encoder.py
    ‚îî‚îÄ‚îÄ tests/
        ‚îú‚îÄ‚îÄ __init__.py
        ‚îú‚îÄ‚îÄ test_encoder.py
        ‚îú‚îÄ‚îÄ test_events.py
        ‚îú‚îÄ‚îÄ test_text_roles.py
        ‚îî‚îÄ‚îÄ test_types.py

================================================
FILE: python-sdk/README.md
================================================
# ag-ui-protocol

Python SDK for the **Agent-User Interaction (AG-UI) Protocol**.

`ag-ui-protocol` provides Python developers with strongly-typed data structures and event encoding for building AG-UI compatible agent servers. Built on Pydantic for robust validation and automatic camelCase serialization for seamless frontend integration.

## Installation

```bash
pip install ag-ui-protocol
poetry add ag-ui-protocol
pipenv install ag-ui-protocol
```

## Features

- üêç **Python-native** ‚Äì Idiomatic Python APIs with full type hints and validation
- üìã **Pydantic models** ‚Äì Runtime validation and automatic JSON serialization
- üîÑ **Streaming events** ‚Äì 16 core event types for real-time agent communication
- ‚ö° **High performance** ‚Äì Efficient event encoding for Server-Sent Events

## Quick example

```python
from ag_ui.core import TextMessageContentEvent, EventType
from ag_ui.encoder import EventEncoder

# Create a streaming text event
event = TextMessageContentEvent(
    type=EventType.TEXT_MESSAGE_CONTENT,
    message_id="msg_123",
    delta="Hello from Python!"
)

# Encode for HTTP streaming
encoder = EventEncoder()
sse_data = encoder.encode(event)
# Output: data: {"type":"TEXT_MESSAGE_CONTENT","messageId":"msg_123","delta":"Hello from Python!"}\n\n
```

## Packages

- **`ag_ui.core`** ‚Äì Types, events, and data models for AG-UI protocol
- **`ag_ui.encoder`** ‚Äì Event encoding utilities for HTTP streaming

## Documentation

- Concepts & architecture: [`docs/concepts`](https://docs.ag-ui.com/concepts/architecture)
- Full API reference: [`docs/sdk/python`](https://docs.ag-ui.com/sdk/python/core/overview)

## Contributing

Bug reports and pull requests are welcome! Please read our [contributing guide](https://docs.ag-ui.com/development/contributing) first.

## License

MIT ¬© 2025 AG-UI Protocol Contributors



================================================
FILE: python-sdk/LICENSE
================================================
Copyright (c) 2025 Tawkit Inc.
Copyright (c) 2025 Markus Ecker

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



================================================
FILE: python-sdk/pyproject.toml
================================================
[tool.poetry]
name = "ag-ui-protocol"
version = "0.1.9"
description = ""
authors = ["Markus Ecker <markus.ecker@gmail.com>"]
readme = "README.md"
license = "MIT"
packages = [{include = "ag_ui", from = "."}]
[tool.poetry.dependencies]
python = "^3.9"
pydantic = "^2.11.2"


[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"



================================================
FILE: python-sdk/ag_ui/py.typed
================================================
[Empty file]


================================================
FILE: python-sdk/ag_ui/core/__init__.py
================================================
"""
This module contains the core types and events for the Agent User Interaction Protocol.
"""

from ag_ui.core.events import (
    EventType,
    BaseEvent,
    TextMessageStartEvent,
    TextMessageContentEvent,
    TextMessageEndEvent,
    TextMessageChunkEvent,
    ThinkingTextMessageStartEvent,
    ThinkingTextMessageContentEvent,
    ThinkingTextMessageEndEvent,
    ToolCallStartEvent,
    ToolCallArgsEvent,
    ToolCallEndEvent,
    ToolCallChunkEvent,
    ToolCallResultEvent,
    ThinkingStartEvent,
    ThinkingEndEvent,
    StateSnapshotEvent,
    StateDeltaEvent,
    MessagesSnapshotEvent,
    RawEvent,
    CustomEvent,
    RunStartedEvent,
    RunFinishedEvent,
    RunErrorEvent,
    StepStartedEvent,
    StepFinishedEvent,
    Event
)

from ag_ui.core.types import (
    FunctionCall,
    ToolCall,
    BaseMessage,
    DeveloperMessage,
    SystemMessage,
    AssistantMessage,
    UserMessage,
    ToolMessage,
    Message,
    Role,
    Context,
    Tool,
    RunAgentInput,
    State
)

__all__ = [
    # Events
    "EventType",
    "BaseEvent",
    "TextMessageStartEvent",
    "TextMessageContentEvent",
    "TextMessageEndEvent",
    "TextMessageChunkEvent",
    "ThinkingTextMessageStartEvent",
    "ThinkingTextMessageContentEvent",
    "ThinkingTextMessageEndEvent",
    "ToolCallStartEvent",
    "ToolCallArgsEvent",
    "ToolCallEndEvent",
    "ToolCallChunkEvent",
    "ToolCallResultEvent",
    "ThinkingStartEvent",
    "ThinkingEndEvent",
    "StateSnapshotEvent",
    "StateDeltaEvent",
    "MessagesSnapshotEvent",
    "RawEvent",
    "CustomEvent",
    "RunStartedEvent",
    "RunFinishedEvent",
    "RunErrorEvent",
    "StepStartedEvent",
    "StepFinishedEvent",
    "Event",
    # Types
    "FunctionCall",
    "ToolCall",
    "BaseMessage",
    "DeveloperMessage",
    "SystemMessage",
    "AssistantMessage",
    "UserMessage",
    "ToolMessage",
    "Message",
    "Role",
    "Context",
    "Tool",
    "RunAgentInput",
    "State"
]



================================================
FILE: python-sdk/ag_ui/core/events.py
================================================
"""
This module contains the event types for the Agent User Interaction Protocol Python SDK.
"""

from enum import Enum
from typing import Annotated, Any, List, Literal, Optional, Union

from pydantic import Field

from .types import ConfiguredBaseModel, Message, State, Role

# Text messages can have any role except "tool"
TextMessageRole = Literal["developer", "system", "assistant", "user"]


class EventType(str, Enum):
    """
    The type of event.
    """
    TEXT_MESSAGE_START = "TEXT_MESSAGE_START"
    TEXT_MESSAGE_CONTENT = "TEXT_MESSAGE_CONTENT"
    TEXT_MESSAGE_END = "TEXT_MESSAGE_END"
    TEXT_MESSAGE_CHUNK = "TEXT_MESSAGE_CHUNK"
    THINKING_TEXT_MESSAGE_START = "THINKING_TEXT_MESSAGE_START"
    THINKING_TEXT_MESSAGE_CONTENT = "THINKING_TEXT_MESSAGE_CONTENT"
    THINKING_TEXT_MESSAGE_END = "THINKING_TEXT_MESSAGE_END"
    TOOL_CALL_START = "TOOL_CALL_START"
    TOOL_CALL_ARGS = "TOOL_CALL_ARGS"
    TOOL_CALL_END = "TOOL_CALL_END"
    TOOL_CALL_CHUNK = "TOOL_CALL_CHUNK"
    TOOL_CALL_RESULT = "TOOL_CALL_RESULT"
    THINKING_START = "THINKING_START"
    THINKING_END = "THINKING_END"
    STATE_SNAPSHOT = "STATE_SNAPSHOT"
    STATE_DELTA = "STATE_DELTA"
    MESSAGES_SNAPSHOT = "MESSAGES_SNAPSHOT"
    RAW = "RAW"
    CUSTOM = "CUSTOM"
    RUN_STARTED = "RUN_STARTED"
    RUN_FINISHED = "RUN_FINISHED"
    RUN_ERROR = "RUN_ERROR"
    STEP_STARTED = "STEP_STARTED"
    STEP_FINISHED = "STEP_FINISHED"


class BaseEvent(ConfiguredBaseModel):
    """
    Base event for all events in the Agent User Interaction Protocol.
    """
    type: EventType
    timestamp: Optional[int] = None
    raw_event: Optional[Any] = None


class TextMessageStartEvent(BaseEvent):
    """
    Event indicating the start of a text message.
    """
    type: Literal[EventType.TEXT_MESSAGE_START] = EventType.TEXT_MESSAGE_START  # pyright: ignore[reportIncompatibleVariableOverride]
    message_id: str
    role: TextMessageRole = "assistant"


class TextMessageContentEvent(BaseEvent):
    """
    Event containing a piece of text message content.
    """
    type: Literal[EventType.TEXT_MESSAGE_CONTENT] = EventType.TEXT_MESSAGE_CONTENT  # pyright: ignore[reportIncompatibleVariableOverride]
    message_id: str
    delta: str = Field(min_length=1)


class TextMessageEndEvent(BaseEvent):
    """
    Event indicating the end of a text message.
    """
    type: Literal[EventType.TEXT_MESSAGE_END] = EventType.TEXT_MESSAGE_END  # pyright: ignore[reportIncompatibleVariableOverride]
    message_id: str

class TextMessageChunkEvent(BaseEvent):
    """
    Event containing a chunk of text message content.
    """
    type: Literal[EventType.TEXT_MESSAGE_CHUNK] = EventType.TEXT_MESSAGE_CHUNK  # pyright: ignore[reportIncompatibleVariableOverride]
    message_id: Optional[str] = None
    role: Optional[TextMessageRole] = None
    delta: Optional[str] = None

class ThinkingTextMessageStartEvent(BaseEvent):
    """
    Event indicating the start of a thinking text message.
    """
    type: Literal[EventType.THINKING_TEXT_MESSAGE_START] = EventType.THINKING_TEXT_MESSAGE_START  # pyright: ignore[reportIncompatibleVariableOverride]

class ThinkingTextMessageContentEvent(BaseEvent):
    """
    Event indicating a piece of a thinking text message.
    """
    type: Literal[EventType.THINKING_TEXT_MESSAGE_CONTENT] = EventType.THINKING_TEXT_MESSAGE_CONTENT  # pyright: ignore[reportIncompatibleVariableOverride]
    delta: str = Field(min_length=1)

class ThinkingTextMessageEndEvent(BaseEvent):
    """
    Event indicating the end of a thinking text message.
    """
    type: Literal[EventType.THINKING_TEXT_MESSAGE_END] = EventType.THINKING_TEXT_MESSAGE_END  # pyright: ignore[reportIncompatibleVariableOverride]

class ToolCallStartEvent(BaseEvent):
    """
    Event indicating the start of a tool call.
    """
    type: Literal[EventType.TOOL_CALL_START] = EventType.TOOL_CALL_START  # pyright: ignore[reportIncompatibleVariableOverride]
    tool_call_id: str
    tool_call_name: str
    parent_message_id: Optional[str] = None


class ToolCallArgsEvent(BaseEvent):
    """
    Event containing tool call arguments.
    """
    type: Literal[EventType.TOOL_CALL_ARGS] = EventType.TOOL_CALL_ARGS  # pyright: ignore[reportIncompatibleVariableOverride]
    tool_call_id: str
    delta: str


class ToolCallEndEvent(BaseEvent):
    """
    Event indicating the end of a tool call.
    """
    type: Literal[EventType.TOOL_CALL_END] = EventType.TOOL_CALL_END  # pyright: ignore[reportIncompatibleVariableOverride]
    tool_call_id: str

class ToolCallChunkEvent(BaseEvent):
    """
    Event containing a chunk of tool call content.
    """
    type: Literal[EventType.TOOL_CALL_CHUNK] = EventType.TOOL_CALL_CHUNK  # pyright: ignore[reportIncompatibleVariableOverride]
    tool_call_id: Optional[str] = None
    tool_call_name: Optional[str] = None
    parent_message_id: Optional[str] = None
    delta: Optional[str] = None

class ToolCallResultEvent(BaseEvent):
    """
    Event containing the result of a tool call.
    """
    message_id: str
    type: Literal[EventType.TOOL_CALL_RESULT] = EventType.TOOL_CALL_RESULT  # pyright: ignore[reportIncompatibleVariableOverride]
    tool_call_id: str
    content: str
    role: Optional[Literal["tool"]] = None

class ThinkingStartEvent(BaseEvent):
    """
    Event indicating the start of a thinking step event.
    """
    type: Literal[EventType.THINKING_START] = EventType.THINKING_START  # pyright: ignore[reportIncompatibleVariableOverride]
    title: Optional[str] = None

class ThinkingEndEvent(BaseEvent):
    """
    Event indicating the end of a thinking step event.
    """
    type: Literal[EventType.THINKING_END] = EventType.THINKING_END  # pyright: ignore[reportIncompatibleVariableOverride]

class StateSnapshotEvent(BaseEvent):
    """
    Event containing a snapshot of the state.
    """
    type: Literal[EventType.STATE_SNAPSHOT] = EventType.STATE_SNAPSHOT  # pyright: ignore[reportIncompatibleVariableOverride]
    snapshot: State


class StateDeltaEvent(BaseEvent):
    """
    Event containing a delta of the state.
    """
    type: Literal[EventType.STATE_DELTA] = EventType.STATE_DELTA  # pyright: ignore[reportIncompatibleVariableOverride]
    delta: List[Any]  # JSON Patch (RFC 6902)


class MessagesSnapshotEvent(BaseEvent):
    """
    Event containing a snapshot of the messages.
    """
    type: Literal[EventType.MESSAGES_SNAPSHOT] = EventType.MESSAGES_SNAPSHOT  # pyright: ignore[reportIncompatibleVariableOverride]
    messages: List[Message]


class RawEvent(BaseEvent):
    """
    Event containing a raw event.
    """
    type: Literal[EventType.RAW] = EventType.RAW  # pyright: ignore[reportIncompatibleVariableOverride]
    event: Any
    source: Optional[str] = None


class CustomEvent(BaseEvent):
    """
    Event containing a custom event.
    """
    type: Literal[EventType.CUSTOM] = EventType.CUSTOM  # pyright: ignore[reportIncompatibleVariableOverride]
    name: str
    value: Any


class RunStartedEvent(BaseEvent):
    """
    Event indicating that a run has started.
    """
    type: Literal[EventType.RUN_STARTED] = EventType.RUN_STARTED  # pyright: ignore[reportIncompatibleVariableOverride]
    thread_id: str
    run_id: str


class RunFinishedEvent(BaseEvent):
    """
    Event indicating that a run has finished.
    """
    type: Literal[EventType.RUN_FINISHED] = EventType.RUN_FINISHED  # pyright: ignore[reportIncompatibleVariableOverride]
    thread_id: str
    run_id: str
    result: Optional[Any] = None


class RunErrorEvent(BaseEvent):
    """
    Event indicating that a run has encountered an error.
    """
    type: Literal[EventType.RUN_ERROR] = EventType.RUN_ERROR  # pyright: ignore[reportIncompatibleVariableOverride]
    message: str
    code: Optional[str] = None


class StepStartedEvent(BaseEvent):
    """
    Event indicating that a step has started.
    """
    type: Literal[EventType.STEP_STARTED] = EventType.STEP_STARTED  # pyright: ignore[reportIncompatibleVariableOverride]
    step_name: str


class StepFinishedEvent(BaseEvent):
    """
    Event indicating that a step has finished.
    """
    type: Literal[EventType.STEP_FINISHED] = EventType.STEP_FINISHED  # pyright: ignore[reportIncompatibleVariableOverride]
    step_name: str


Event = Annotated[
    Union[
        TextMessageStartEvent,
        TextMessageContentEvent,
        TextMessageEndEvent,
        TextMessageChunkEvent,
        ToolCallStartEvent,
        ToolCallArgsEvent,
        ToolCallEndEvent,
        ToolCallChunkEvent,
        ToolCallResultEvent,
        StateSnapshotEvent,
        StateDeltaEvent,
        MessagesSnapshotEvent,
        RawEvent,
        CustomEvent,
        RunStartedEvent,
        RunFinishedEvent,
        RunErrorEvent,
        StepStartedEvent,
        StepFinishedEvent,
    ],
    Field(discriminator="type")
]



================================================
FILE: python-sdk/ag_ui/core/types.py
================================================
"""
This module contains the types for the Agent User Interaction Protocol Python SDK.
"""

from typing import Annotated, Any, List, Literal, Optional, Union

from pydantic import BaseModel, ConfigDict, Field
from pydantic.alias_generators import to_camel


class ConfiguredBaseModel(BaseModel):
    """
    A configurable base model.
    """
    model_config = ConfigDict(
        extra="forbid",
        alias_generator=to_camel,
        populate_by_name=True,
    )


class FunctionCall(ConfiguredBaseModel):
    """
    Name and arguments of a function call.
    """
    name: str
    arguments: str


class ToolCall(ConfiguredBaseModel):
    """
    A tool call, modelled after OpenAI tool calls.
    """
    id: str
    type: Literal["function"] = "function"  # pyright: ignore[reportIncompatibleVariableOverride]
    function: FunctionCall


class BaseMessage(ConfiguredBaseModel):
    """
    A base message, modelled after OpenAI messages.
    """
    id: str
    role: str
    content: Optional[str] = None
    name: Optional[str] = None


class DeveloperMessage(BaseMessage):
    """
    A developer message.
    """
    role: Literal["developer"] = "developer"  # pyright: ignore[reportIncompatibleVariableOverride]
    content: str


class SystemMessage(BaseMessage):
    """
    A system message.
    """
    role: Literal["system"] = "system"  # pyright: ignore[reportIncompatibleVariableOverride]
    content: str


class AssistantMessage(BaseMessage):
    """
    An assistant message.
    """
    role: Literal["assistant"] = "assistant"  # pyright: ignore[reportIncompatibleVariableOverride]
    tool_calls: Optional[List[ToolCall]] = None


class UserMessage(BaseMessage):
    """
    A user message.
    """
    role: Literal["user"] = "user" # pyright: ignore[reportIncompatibleVariableOverride]
    content: str


class ToolMessage(ConfiguredBaseModel):
    """
    A tool result message.
    """
    id: str
    role: Literal["tool"] = "tool"
    content: str
    tool_call_id: str
    error: Optional[str] = None


Message = Annotated[
    Union[DeveloperMessage, SystemMessage, AssistantMessage, UserMessage, ToolMessage],
    Field(discriminator="role")
]

Role = Literal["developer", "system", "assistant", "user", "tool"]


class Context(ConfiguredBaseModel):
    """
    Additional context for the agent.
    """
    description: str
    value: str


class Tool(ConfiguredBaseModel):
    """
    A tool definition.
    """
    name: str
    description: str
    parameters: Any  # JSON Schema for the tool parameters


class RunAgentInput(ConfiguredBaseModel):
    """
    Input for running an agent.
    """
    thread_id: str
    run_id: str
    state: Any
    messages: List[Message]
    tools: List[Tool]
    context: List[Context]
    forwarded_props: Any


# State can be any type
State = Any



================================================
FILE: python-sdk/ag_ui/encoder/__init__.py
================================================
"""
This module contains the EventEncoder class.
"""

from ag_ui.encoder.encoder import EventEncoder, AGUI_MEDIA_TYPE

__all__ = ["EventEncoder", "AGUI_MEDIA_TYPE"]



================================================
FILE: python-sdk/ag_ui/encoder/encoder.py
================================================
"""
This module contains the EventEncoder class
"""

from ag_ui.core.events import BaseEvent

AGUI_MEDIA_TYPE = "application/vnd.ag-ui.event+proto"

class EventEncoder:
    """
    Encodes Agent User Interaction events.
    """
    def __init__(self, accept: str = None):
        pass

    def get_content_type(self) -> str:
        """
        Returns the content type of the encoder.
        """
        return "text/event-stream"

    def encode(self, event: BaseEvent) -> str:
        """
        Encodes an event.
        """
        return self._encode_sse(event)

    def _encode_sse(self, event: BaseEvent) -> str:
        """
        Encodes an event into an SSE string.
        """
        return f"data: {event.model_dump_json(by_alias=True, exclude_none=True)}\n\n"



================================================
FILE: python-sdk/tests/__init__.py
================================================
[Empty file]


================================================
FILE: python-sdk/tests/test_encoder.py
================================================
import unittest
import json
from datetime import datetime

from ag_ui.encoder.encoder import EventEncoder, AGUI_MEDIA_TYPE
from ag_ui.core.events import BaseEvent, EventType, TextMessageContentEvent, ToolCallStartEvent


class TestEventEncoder(unittest.TestCase):
    """Test suite for EventEncoder class"""

    def test_encoder_initialization(self):
        """Test initializing an EventEncoder"""
        encoder = EventEncoder()
        self.assertIsInstance(encoder, EventEncoder)

        # Test with accept parameter
        encoder_with_accept = EventEncoder(accept=AGUI_MEDIA_TYPE)
        self.assertIsInstance(encoder_with_accept, EventEncoder)

    def test_encode_method(self):
        """Test the encode method which calls encode_sse"""
        # Create a test event
        timestamp = int(datetime.now().timestamp() * 1000)
        event = BaseEvent(type=EventType.RAW, timestamp=timestamp)
        
        # Create encoder and encode event
        encoder = EventEncoder()
        encoded = encoder.encode(event)
        
        # The encode method calls encode_sse, so the result should be in SSE format
        expected = f"data: {event.model_dump_json(by_alias=True, exclude_none=True)}\n\n"
        self.assertEqual(encoded, expected)
        
        # Verify that camelCase is used in the encoded output
        self.assertIn('"type":', encoded)
        self.assertIn('"timestamp":', encoded)
        # Raw event should be excluded if it's None
        self.assertNotIn('"rawEvent":', encoded)
        self.assertNotIn('"raw_event":', encoded)

    def test_encode_sse_method(self):
        """Test the encode_sse method"""
        # Create a test event with specific data
        event = TextMessageContentEvent(
            message_id="msg_123",
            delta="Hello, world!",
            timestamp=1648214400000
        )
        
        # Create encoder and encode event to SSE
        encoder = EventEncoder()
        encoded_sse = encoder._encode_sse(event)
        
        # Verify the format is correct for SSE (data: [json]\n\n)
        self.assertTrue(encoded_sse.startswith("data: "))
        self.assertTrue(encoded_sse.endswith("\n\n"))
        
        # Extract and verify the JSON content
        json_content = encoded_sse[6:-2]  # Remove "data: " prefix and "\n\n" suffix
        decoded = json.loads(json_content)
        
        # Check that all fields were properly encoded
        self.assertEqual(decoded["type"], "TEXT_MESSAGE_CONTENT")
        self.assertEqual(decoded["messageId"], "msg_123")  # Check snake_case converted to camelCase
        self.assertEqual(decoded["delta"], "Hello, world!")
        self.assertEqual(decoded["timestamp"], 1648214400000)
        
        # Verify that snake_case has been converted to camelCase
        self.assertIn("messageId", decoded)  # camelCase key exists
        self.assertNotIn("message_id", decoded)  # snake_case key doesn't exist

    def test_encode_with_different_event_types(self):
        """Test encoding different types of events"""
        # Create encoder
        encoder = EventEncoder()
        
        # Test with a basic BaseEvent
        base_event = BaseEvent(type=EventType.RAW, timestamp=1648214400000)
        encoded_base = encoder.encode(base_event)
        self.assertIn('"type":"RAW"', encoded_base)
        
        # Test with a more complex event
        content_event = TextMessageContentEvent(
            message_id="msg_456",
            delta="Testing different events",
            timestamp=1648214400000
        )
        encoded_content = encoder.encode(content_event)
        
        # Verify correct encoding and camelCase conversion
        self.assertIn('"type":"TEXT_MESSAGE_CONTENT"', encoded_content)
        self.assertIn('"messageId":"msg_456"', encoded_content)  # Check snake_case converted to camelCase
        self.assertIn('"delta":"Testing different events"', encoded_content)
        
        # Extract JSON and verify camelCase conversion
        json_content = encoded_content.split("data: ")[1].rstrip("\n\n")
        decoded = json.loads(json_content)
        
        # Verify messageId is camelCase (not message_id)
        self.assertIn("messageId", decoded)
        self.assertNotIn("message_id", decoded)
        
    def test_null_value_exclusion(self):
        """Test that fields with None values are excluded from the JSON output"""
        # Create an event with some fields set to None
        event = BaseEvent(
            type=EventType.RAW,
            timestamp=1648214400000,
            raw_event=None  # Explicitly set to None
        )
        
        # Create encoder and encode event
        encoder = EventEncoder()
        encoded = encoder.encode(event)
        
        # Extract JSON
        json_content = encoded.split("data: ")[1].rstrip("\n\n")
        decoded = json.loads(json_content)
        
        # Verify fields that are present
        self.assertIn("type", decoded)
        self.assertIn("timestamp", decoded)
        
        # Verify null fields are excluded
        self.assertNotIn("rawEvent", decoded)
        
        # Test with another event that has optional fields
        # Create event with some optional fields set to None
        event_with_optional = ToolCallStartEvent(
            tool_call_id="call_123",
            tool_call_name="test_tool",
            parent_message_id=None,  # Optional field explicitly set to None
            timestamp=1648214400000
        )
        
        encoded_optional = encoder.encode(event_with_optional)
        json_content_optional = encoded_optional.split("data: ")[1].rstrip("\n\n")
        decoded_optional = json.loads(json_content_optional)
        
        # Required fields should be present
        self.assertIn("toolCallId", decoded_optional)
        self.assertIn("toolCallName", decoded_optional)
        
        # Optional field with None value should be excluded
        self.assertNotIn("parentMessageId", decoded_optional)
        
    def test_round_trip_serialization(self):
        """Test that events can be serialized to JSON with camelCase and deserialized back correctly"""
        # Create a complex event with multiple fields
        original_event = ToolCallStartEvent(
            tool_call_id="call_abc123",
            tool_call_name="search_tool",
            parent_message_id="msg_parent_456",
            timestamp=1648214400000
        )
        
        # Serialize to JSON with camelCase fields
        json_str = original_event.model_dump_json(by_alias=True)
        
        # Verify JSON uses camelCase
        json_data = json.loads(json_str)
        self.assertIn("toolCallId", json_data)
        self.assertIn("toolCallName", json_data)
        self.assertIn("parentMessageId", json_data)
        self.assertNotIn("tool_call_id", json_data)
        self.assertNotIn("tool_call_name", json_data)
        self.assertNotIn("parent_message_id", json_data)
        
        # Deserialize back to an event
        deserialized_event = ToolCallStartEvent.model_validate_json(json_str)
        
        # Verify the deserialized event is equivalent to the original
        self.assertEqual(deserialized_event.type, original_event.type)
        self.assertEqual(deserialized_event.tool_call_id, original_event.tool_call_id)
        self.assertEqual(deserialized_event.tool_call_name, original_event.tool_call_name)
        self.assertEqual(deserialized_event.parent_message_id, original_event.parent_message_id)
        self.assertEqual(deserialized_event.timestamp, original_event.timestamp)
        
        # Verify complete equality using model_dump
        self.assertEqual(
            original_event.model_dump(), 
            deserialized_event.model_dump()
        )



================================================
FILE: python-sdk/tests/test_events.py
================================================
import unittest
import json
from datetime import datetime
from pydantic import ValidationError, TypeAdapter

from ag_ui.core.types import Message, UserMessage, AssistantMessage, FunctionCall, ToolCall
from ag_ui.core.events import (
    EventType,
    BaseEvent,
    TextMessageStartEvent,
    TextMessageContentEvent,
    TextMessageEndEvent,
    ToolCallStartEvent,
    ToolCallArgsEvent,
    ToolCallEndEvent,
    StateSnapshotEvent,
    StateDeltaEvent,
    MessagesSnapshotEvent,
    RawEvent,
    CustomEvent,
    RunStartedEvent,
    RunFinishedEvent,
    RunErrorEvent,
    StepStartedEvent,
    StepFinishedEvent,
    Event
)


class TestEvents(unittest.TestCase):
    """Test suite for event classes"""

    def test_event_types_enum(self):
        """Test the EventType enum values"""
        self.assertEqual(EventType.TEXT_MESSAGE_START.value, "TEXT_MESSAGE_START")
        self.assertEqual(EventType.TOOL_CALL_ARGS.value, "TOOL_CALL_ARGS")
        self.assertEqual(EventType.STATE_SNAPSHOT.value, "STATE_SNAPSHOT")
        self.assertEqual(EventType.RUN_ERROR.value, "RUN_ERROR")
        self.assertEqual(EventType.STEP_FINISHED.value, "STEP_FINISHED")

    def test_base_event_creation(self):
        """Test creating a BaseEvent instance"""
        timestamp = int(datetime.now().timestamp() * 1000)
        event = BaseEvent(type=EventType.RAW, timestamp=timestamp)
        self.assertEqual(event.type, EventType.RAW)
        self.assertEqual(event.timestamp, timestamp)
        self.assertIsNone(event.raw_event)

    def test_text_message_start(self):
        """Test creating and serializing a TextMessageStartEvent event"""
        event = TextMessageStartEvent(
            message_id="msg_123",
            timestamp=1648214400000
        )
        self.assertEqual(event.message_id, "msg_123")
        self.assertEqual(event.role, "assistant")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "TEXT_MESSAGE_START")
        self.assertEqual(serialized["messageId"], "msg_123")
        self.assertEqual(serialized["timestamp"], 1648214400000)

    def test_text_message_content(self):
        """Test creating and serializing a TextMessageContentEvent event"""
        event = TextMessageContentEvent(
            message_id="msg_123",
            delta="Hello, world!",
            timestamp=1648214400000
        )
        self.assertEqual(event.message_id, "msg_123")
        self.assertEqual(event.delta, "Hello, world!")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "TEXT_MESSAGE_CONTENT")
        self.assertEqual(serialized["messageId"], "msg_123")
        self.assertEqual(serialized["delta"], "Hello, world!")

    def test_text_message_end(self):
        """Test creating and serializing a TextMessageEndEvent event"""
        event = TextMessageEndEvent(
            message_id="msg_123",
            timestamp=1648214400000
        )
        self.assertEqual(event.message_id, "msg_123")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "TEXT_MESSAGE_END")
        self.assertEqual(serialized["messageId"], "msg_123")

    def test_tool_call_start(self):
        """Test creating and serializing a ToolCallStartEvent event"""
        event = ToolCallStartEvent(
            tool_call_id="call_123",
            tool_call_name="get_weather",
            parent_message_id="msg_456",
            timestamp=1648214400000
        )
        self.assertEqual(event.tool_call_id, "call_123")
        self.assertEqual(event.tool_call_name, "get_weather")
        self.assertEqual(event.parent_message_id, "msg_456")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "TOOL_CALL_START")
        self.assertEqual(serialized["toolCallId"], "call_123")
        self.assertEqual(serialized["toolCallName"], "get_weather")
        self.assertEqual(serialized["parentMessageId"], "msg_456")

    def test_tool_call_args(self):
        """Test creating and serializing a ToolCallArgsEvent event"""
        event = ToolCallArgsEvent(
            tool_call_id="call_123",
            delta='{"location": "New York"}',
            timestamp=1648214400000
        )
        self.assertEqual(event.tool_call_id, "call_123")
        self.assertEqual(event.delta, '{"location": "New York"}')
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "TOOL_CALL_ARGS")
        self.assertEqual(serialized["toolCallId"], "call_123")
        self.assertEqual(serialized["delta"], '{"location": "New York"}')

    def test_tool_call_end(self):
        """Test creating and serializing a ToolCallEndEvent event"""
        event = ToolCallEndEvent(
            tool_call_id="call_123",
            timestamp=1648214400000
        )
        self.assertEqual(event.tool_call_id, "call_123")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "TOOL_CALL_END")
        self.assertEqual(serialized["toolCallId"], "call_123")

    def test_state_snapshot(self):
        """Test creating and serializing a StateSnapshotEvent event"""
        state = {"conversation_state": "active", "user_info": {"name": "John"}}
        event = StateSnapshotEvent(
            snapshot=state,
            timestamp=1648214400000
        )
        self.assertEqual(event.snapshot, state)
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "STATE_SNAPSHOT")
        self.assertEqual(serialized["snapshot"]["conversation_state"], "active")
        self.assertEqual(serialized["snapshot"]["user_info"]["name"], "John")

    def test_state_delta(self):
        """Test creating and serializing a StateDeltaEvent event"""
        # JSON Patch format
        delta = [
            {"op": "replace", "path": "/conversation_state", "value": "paused"},
            {"op": "add", "path": "/user_info/age", "value": 30}
        ]
        event = StateDeltaEvent(
            delta=delta,
            timestamp=1648214400000
        )
        self.assertEqual(event.delta, delta)
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "STATE_DELTA")
        self.assertEqual(len(serialized["delta"]), 2)
        self.assertEqual(serialized["delta"][0]["op"], "replace")
        self.assertEqual(serialized["delta"][1]["path"], "/user_info/age")

    def test_messages_snapshot(self):
        """Test creating and serializing a MessagesSnapshotEvent event"""
        messages = [
            UserMessage(id="user_1", content="Hello"),
            AssistantMessage(id="asst_1", content="Hi there", tool_calls=[
                ToolCall(
                    id="call_1",
                    function=FunctionCall(
                        name="get_weather",
                        arguments='{"location": "New York"}'
                    )
                )
            ])
        ]
        event = MessagesSnapshotEvent(
            messages=messages,
            timestamp=1648214400000
        )
        self.assertEqual(len(event.messages), 2)
        self.assertEqual(event.messages[0].id, "user_1")
        self.assertEqual(event.messages[1].tool_calls[0].function.name, "get_weather")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "MESSAGES_SNAPSHOT")
        self.assertEqual(len(serialized["messages"]), 2)
        self.assertEqual(serialized["messages"][0]["role"], "user")
        self.assertEqual(serialized["messages"][1]["toolCalls"][0]["function"]["name"], "get_weather")

    def test_raw_event(self):
        """Test creating and serializing a RawEvent"""
        raw_data = {"origin": "server", "data": {"key": "value"}}
        event = RawEvent(
            event=raw_data,
            source="api",
            timestamp=1648214400000
        )
        self.assertEqual(event.event, raw_data)
        self.assertEqual(event.source, "api")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "RAW")
        self.assertEqual(serialized["event"]["origin"], "server")
        self.assertEqual(serialized["source"], "api")

    def test_custom_event(self):
        """Test creating and serializing a CustomEvent"""
        event = CustomEvent(
            name="user_action",
            value={"action": "click", "element": "button"},
            timestamp=1648214400000
        )
        self.assertEqual(event.name, "user_action")
        self.assertEqual(event.value["action"], "click")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "CUSTOM")
        self.assertEqual(serialized["name"], "user_action")
        self.assertEqual(serialized["value"]["element"], "button")

    def test_run_started(self):
        """Test creating and serializing a RunStartedEvent event"""
        event = RunStartedEvent(
            thread_id="thread_123",
            run_id="run_456",
            timestamp=1648214400000
        )
        self.assertEqual(event.thread_id, "thread_123")
        self.assertEqual(event.run_id, "run_456")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "RUN_STARTED")
        self.assertEqual(serialized["threadId"], "thread_123")
        self.assertEqual(serialized["runId"], "run_456")

    def test_run_finished(self):
        """Test creating and serializing a RunFinishedEvent event"""
        event = RunFinishedEvent(
            thread_id="thread_123",
            run_id="run_456",
            timestamp=1648214400000
        )
        self.assertEqual(event.thread_id, "thread_123")
        self.assertEqual(event.run_id, "run_456")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "RUN_FINISHED")
        self.assertEqual(serialized["threadId"], "thread_123")
        self.assertEqual(serialized["runId"], "run_456")

    def test_run_error(self):
        """Test creating and serializing a RunErrorEvent event"""
        event = RunErrorEvent(
            message="An error occurred during execution",
            code="ERROR_001",
            timestamp=1648214400000
        )
        self.assertEqual(event.message, "An error occurred during execution")
        self.assertEqual(event.code, "ERROR_001")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "RUN_ERROR")
        self.assertEqual(serialized["message"], "An error occurred during execution")
        self.assertEqual(serialized["code"], "ERROR_001")

    def test_step_started(self):
        """Test creating and serializing a StepStartedEvent event"""
        event = StepStartedEvent(
            step_name="process_data",
            timestamp=1648214400000
        )
        self.assertEqual(event.step_name, "process_data")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "STEP_STARTED")
        self.assertEqual(serialized["stepName"], "process_data")

    def test_step_finished(self):
        """Test creating and serializing a StepFinishedEvent event"""
        event = StepFinishedEvent(
            step_name="process_data",
            timestamp=1648214400000
        )
        self.assertEqual(event.step_name, "process_data")
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "STEP_FINISHED")
        self.assertEqual(serialized["stepName"], "process_data")

    def test_event_union_deserialization(self):
        """Test the Event union type correctly deserializes different event types"""
        event_adapter = TypeAdapter(Event)
        
        # Test different event types
        event_data = [
            {
                "type": "TEXT_MESSAGE_START",
                "messageId": "msg_start",
                "role": "assistant",
                "timestamp": 1648214400000
            },
            {
                "type": "TEXT_MESSAGE_CONTENT",
                "messageId": "msg_content",
                "delta": "Hello!",
                "timestamp": 1648214400000
            },
            {
                "type": "TOOL_CALL_START",
                "toolCallId": "call_start",
                "toolCallName": "get_info",
                "timestamp": 1648214400000
            },
            {
                "type": "STATE_SNAPSHOT",
                "snapshot": {"status": "active"},
                "timestamp": 1648214400000
            },
            {
                "type": "RUN_ERROR",
                "message": "Error occurred",
                "code": "ERR_001",
                "timestamp": 1648214400000
            }
        ]
        
        expected_types = [
            TextMessageStartEvent,
            TextMessageContentEvent,
            ToolCallStartEvent,
            StateSnapshotEvent,
            RunErrorEvent
        ]
        
        for data, expected_type in zip(event_data, expected_types):
            event = event_adapter.validate_python(data)
            self.assertIsInstance(event, expected_type)
            self.assertEqual(event.type.value, data["type"])
            self.assertEqual(event.timestamp, data["timestamp"])

    def test_validation_constraints(self):
        """Test validation constraints for different event types"""
        # TextMessageContentEvent delta cannot be empty
        with self.assertRaises(ValueError):
            TextMessageContentEvent(
                message_id="msg_123",
                delta=""  # Empty delta, should fail
            )

    def test_serialization_round_trip(self):
        """Test serialization and deserialization for different event types"""
        # Create events of different types
        events = [
            TextMessageStartEvent(
                message_id="msg_123",
            ),
            TextMessageContentEvent(
                message_id="msg_123",
                delta="Hello, world!"
            ),
            ToolCallStartEvent(
                tool_call_id="call_123",
                tool_call_name="get_weather"
            ),
            StateSnapshotEvent(
                snapshot={"status": "active"}
            ),
            MessagesSnapshotEvent(
                messages=[
                    UserMessage(id="user_1", content="Hello")
                ]
            ),
            RunStartedEvent(
                thread_id="thread_123",
                run_id="run_456"
            )
        ]
        
        event_adapter = TypeAdapter(Event)
        
        # Test round trip for each event
        for original_event in events:
            # Serialize to JSON
            json_str = original_event.model_dump_json(by_alias=True)
            
            # Deserialize back to object
            deserialized_event = event_adapter.validate_json(json_str)
            
            # Verify the types match
            self.assertIsInstance(deserialized_event, type(original_event))
            self.assertEqual(deserialized_event.type, original_event.type)
            
            # Verify event-specific fields
            if isinstance(original_event, TextMessageStartEvent):
                self.assertEqual(deserialized_event.message_id, original_event.message_id)
                self.assertEqual(deserialized_event.role, original_event.role)
            elif isinstance(original_event, TextMessageContentEvent):
                self.assertEqual(deserialized_event.message_id, original_event.message_id)
                self.assertEqual(deserialized_event.delta, original_event.delta)
            elif isinstance(original_event, ToolCallStartEvent):
                self.assertEqual(deserialized_event.tool_call_id, original_event.tool_call_id)
                self.assertEqual(deserialized_event.tool_call_name, original_event.tool_call_name)
            elif isinstance(original_event, StateSnapshotEvent):
                self.assertEqual(deserialized_event.snapshot, original_event.snapshot)
            elif isinstance(original_event, MessagesSnapshotEvent):
                self.assertEqual(len(deserialized_event.messages), len(original_event.messages))
                self.assertEqual(deserialized_event.messages[0].id, original_event.messages[0].id)
            elif isinstance(original_event, RunStartedEvent):
                self.assertEqual(deserialized_event.thread_id, original_event.thread_id)
                self.assertEqual(deserialized_event.run_id, original_event.run_id)

    def test_raw_event_with_null_source(self):
        """Test RawEvent with null source"""
        event = RawEvent(
            event={"data": "test"},
            source=None  # Explicit None
        )
        self.assertIsNone(event.source)
        
        # Test serialization
        serialized = event.model_dump(by_alias=True)
        self.assertEqual(serialized["type"], "RAW")
        self.assertEqual(serialized["event"]["data"], "test")
        self.assertIsNone(serialized["source"])
        
        # Test round-trip
        event_adapter = TypeAdapter(Event)
        json_str = event.model_dump_json(by_alias=True)
        deserialized = event_adapter.validate_json(json_str)
        self.assertIsNone(deserialized.source)

    def test_complex_nested_event_structures(self):
        """Test complex nested structures within events"""
        # Complex state with nested objects and arrays
        complex_state = {
            "session": {
                "user": {
                    "id": "user_123",
                    "preferences": {
                        "theme": "dark",
                        "notifications": True,
                        "filters": ["news", "social", "tech"]
                    }
                },
                "stats": {
                    "messages": 42,
                    "interactions": {
                        "clicks": 18,
                        "searches": 7
                    }
                }
            },
            "active_tools": ["search", "calculator", "weather"],
            "settings": {
                "language": "en",
                "timezone": "UTC-5"
            }
        }
        
        event = StateSnapshotEvent(
            snapshot=complex_state,
            timestamp=1648214400000
        )
        
        # Verify complex state structure
        self.assertEqual(event.snapshot["session"]["user"]["id"], "user_123")
        self.assertEqual(event.snapshot["session"]["user"]["preferences"]["theme"], "dark")
        self.assertEqual(event.snapshot["session"]["stats"]["interactions"]["searches"], 7)
        self.assertEqual(event.snapshot["active_tools"][1], "calculator")
        
        # Test serialization and deserialization
        event_adapter = TypeAdapter(Event)
        json_str = event.model_dump_json(by_alias=True)
        deserialized = event_adapter.validate_json(json_str)
        
        # Verify structure is preserved
        self.assertEqual(
            deserialized.snapshot["session"]["user"]["preferences"]["filters"],
            ["news", "social", "tech"]
        )
        self.assertEqual(deserialized.snapshot["settings"]["timezone"], "UTC-5")

    def test_event_with_unicode_and_special_chars(self):
        """Test events with Unicode and special characters"""
        # Text with Unicode and special characters
        text = "Hello ‰Ω†Â•Ω „Åì„Çì„Å´„Å°„ÅØ ÏïàÎÖïÌïòÏÑ∏Ïöî üëã üåç \n\t\"'\\/<>{}[]"
        
        event = TextMessageContentEvent(
            message_id="msg_unicode",
            delta=text,
            timestamp=1648214400000
        )
        
        # Verify text is stored correctly
        self.assertEqual(event.delta, text)
        
        # Test serialization and deserialization
        event_adapter = TypeAdapter(Event)
        json_str = event.model_dump_json(by_alias=True)
        deserialized = event_adapter.validate_json(json_str)
        
        # Verify Unicode and special characters are preserved
        self.assertEqual(deserialized.delta, text)


if __name__ == "__main__":
    unittest.main()



================================================
FILE: python-sdk/tests/test_text_roles.py
================================================
"""Tests for text message events with different roles."""

import unittest
from pydantic import ValidationError
from ag_ui.core import (
    EventType,
    TextMessageStartEvent,
    TextMessageContentEvent,
    TextMessageEndEvent,
    TextMessageChunkEvent,
    Role,
)

# Test all available roles for text messages (excluding "tool")
TEXT_MESSAGE_ROLES = ["developer", "system", "assistant", "user"]


class TestTextMessageRoles(unittest.TestCase):
    """Test text message events with different roles."""

    def test_text_message_start_with_all_roles(self) -> None:
        """Test TextMessageStartEvent with different roles."""
        for role in TEXT_MESSAGE_ROLES:
            with self.subTest(role=role):
                event = TextMessageStartEvent(
                    message_id="test-msg",
                    role=role,
                )
                
                self.assertEqual(event.type, EventType.TEXT_MESSAGE_START)
                self.assertEqual(event.message_id, "test-msg")
                self.assertEqual(event.role, role)

    def test_text_message_chunk_with_all_roles(self) -> None:
        """Test TextMessageChunkEvent with different roles."""
        for role in TEXT_MESSAGE_ROLES:
            with self.subTest(role=role):
                event = TextMessageChunkEvent(
                    message_id="test-msg",
                    role=role,
                    delta=f"Hello from {role}",
                )
                
                self.assertEqual(event.type, EventType.TEXT_MESSAGE_CHUNK)
                self.assertEqual(event.message_id, "test-msg")
                self.assertEqual(event.role, role)
                self.assertEqual(event.delta, f"Hello from {role}")

    def test_text_message_chunk_without_role(self) -> None:
        """Test TextMessageChunkEvent without role (should be optional)."""
        event = TextMessageChunkEvent(
            message_id="test-msg",
            delta="Hello without role",
        )
        
        self.assertEqual(event.type, EventType.TEXT_MESSAGE_CHUNK)
        self.assertEqual(event.message_id, "test-msg")
        self.assertIsNone(event.role)
        self.assertEqual(event.delta, "Hello without role")

    def test_multiple_messages_different_roles(self) -> None:
        """Test creating multiple messages with different roles."""
        events = []
        
        for role in TEXT_MESSAGE_ROLES:
            start_event = TextMessageStartEvent(
                message_id=f"msg-{role}",
                role=role,
            )
            content_event = TextMessageContentEvent(
                message_id=f"msg-{role}",
                delta=f"Message from {role}",
            )
            end_event = TextMessageEndEvent(
                message_id=f"msg-{role}",
            )
            
            events.extend([start_event, content_event, end_event])
        
        # Verify we have 3 events per role
        self.assertEqual(len(events), len(TEXT_MESSAGE_ROLES) * 3)
        
        # Verify each start event has the correct role
        for i, role in enumerate(TEXT_MESSAGE_ROLES):
            start_event = events[i * 3]
            self.assertIsInstance(start_event, TextMessageStartEvent)
            self.assertEqual(start_event.role, role)
            self.assertEqual(start_event.message_id, f"msg-{role}")

    def test_text_message_serialization(self) -> None:
        """Test that text message events serialize correctly with roles."""
        for role in TEXT_MESSAGE_ROLES:
            with self.subTest(role=role):
                event = TextMessageStartEvent(
                    message_id="test-msg",
                    role=role,
                )
                
                # Convert to dict and back
                event_dict = event.model_dump()
                self.assertEqual(event_dict["role"], role)
                self.assertEqual(event_dict["type"], EventType.TEXT_MESSAGE_START)
                self.assertEqual(event_dict["message_id"], "test-msg")
                
                # Recreate from dict
                new_event = TextMessageStartEvent(**event_dict)
                self.assertEqual(new_event.role, role)
                self.assertEqual(new_event, event)

    def test_invalid_role_rejected(self) -> None:
        """Test that invalid roles are rejected."""
        # Test with completely invalid role
        with self.assertRaises(ValidationError):
            TextMessageStartEvent(
                message_id="test-msg",
                role="invalid_role",  # type: ignore
            )
        
        # Test that 'tool' role is not allowed for text messages
        with self.assertRaises(ValidationError):
            TextMessageStartEvent(
                message_id="test-msg",
                role="tool",  # type: ignore
            )
        
        # Test that 'tool' role is not allowed for chunks either
        with self.assertRaises(ValidationError):
            TextMessageChunkEvent(
                message_id="test-msg",
                role="tool",  # type: ignore
                delta="Tool message",
            )

    def test_text_message_start_default_role(self) -> None:
        """Test that TextMessageStartEvent defaults to 'assistant' role."""
        event = TextMessageStartEvent(
            message_id="test-msg",
        )
        
        self.assertEqual(event.type, EventType.TEXT_MESSAGE_START)
        self.assertEqual(event.message_id, "test-msg")
        self.assertEqual(event.role, "assistant")  # Should default to assistant


if __name__ == "__main__":
    unittest.main()


================================================
FILE: python-sdk/tests/test_types.py
================================================
import unittest
from pydantic import ValidationError
from pydantic import TypeAdapter

from ag_ui.core.types import (
    FunctionCall,
    ToolCall,
    DeveloperMessage,
    SystemMessage,
    AssistantMessage,
    UserMessage,
    ToolMessage,
    Message,
    RunAgentInput
)


class TestBaseTypes(unittest.TestCase):
    """Test suite for base type classes"""

    def test_function_call_creation(self):
        """Test creating a FunctionCall instance"""
        func_call = FunctionCall(name="test_function", arguments="{}")
        self.assertEqual(func_call.name, "test_function")
        self.assertEqual(func_call.arguments, "{}")

    def test_message_serialization(self):
        """Test serialization of a basic message"""
        user_msg = UserMessage(
            id="msg_123",
            content="Hello, world!"
        )
        serialized = user_msg.model_dump(by_alias=True)
        self.assertEqual(serialized["id"], "msg_123")
        self.assertEqual(serialized["role"], "user")
        self.assertEqual(serialized["content"], "Hello, world!")

    def test_tool_call_serialization(self):
        """Test camel case serialization for ConfiguredBaseModel subclasses"""
        tool_call = ToolCall(
            id="call_123",
            function=FunctionCall(name="test_function", arguments="{}")
        )
        serialized = tool_call.model_dump(by_alias=True)
        # Should convert function to camelCase
        self.assertIn("function", serialized)

    def test_tool_message_camel_case(self):
        """Test camel case serialization for ToolMessage"""
        tool_msg = ToolMessage(
            id="tool_123",
            content="Tool result",
            tool_call_id="call_456"
        )
        serialized = tool_msg.model_dump(by_alias=True)
        self.assertIn("toolCallId", serialized)
        self.assertEqual(serialized["toolCallId"], "call_456")

    def test_parse_camel_case_json_tool_message(self):
        """Test parsing JSON with camelCase field names"""
        # JSON data with camelCase field names
        json_data = {
            "id": "tool_789",
            "role": "tool",
            "content": "Result from tool",
            "toolCallId": "call_123"  # camelCase field name
        }

        # Parse the JSON data into a ToolMessage instance
        tool_msg = ToolMessage.model_validate(json_data)

        # Verify fields are correctly set
        self.assertEqual(tool_msg.id, "tool_789")
        self.assertEqual(tool_msg.role, "tool")
        self.assertEqual(tool_msg.content, "Result from tool")
        self.assertEqual(tool_msg.tool_call_id, "call_123")

    def test_parse_camel_case_json_function_call(self):
        """Test parsing function call with camelCase fields"""
        # Create a tool call with nested function call in camelCase
        json_data = {
            "id": "call_abc",
            "type": "function",
            "function": {
                "name": "get_weather",
                "arguments": '{"location":"New York"}'
            }
        }

        # Parse JSON into a ToolCall instance
        tool_call = ToolCall.model_validate(json_data)

        # Verify fields are correctly set
        self.assertEqual(tool_call.id, "call_abc")
        self.assertEqual(tool_call.type, "function")
        self.assertEqual(tool_call.function.name, "get_weather")
        self.assertEqual(tool_call.function.arguments, '{"location":"New York"}')

    def test_developer_message(self):
        """Test creating and serializing a developer message"""
        msg = DeveloperMessage(
            id="dev_123",
            content="Developer note"
        )
        serialized = msg.model_dump(by_alias=True)
        self.assertEqual(serialized["role"], "developer")
        self.assertEqual(serialized["content"], "Developer note")

    def test_system_message(self):
        """Test creating and serializing a system message"""
        msg = SystemMessage(
            id="sys_123",
            content="System instruction"
        )
        serialized = msg.model_dump(by_alias=True)
        self.assertEqual(serialized["role"], "system")
        self.assertEqual(serialized["content"], "System instruction")

    def test_assistant_message(self):
        """Test creating and serializing an assistant message with tool calls"""
        tool_call = ToolCall(
            id="call_456",
            function=FunctionCall(name="get_data", arguments='{"param": "value"}')
        )
        msg = AssistantMessage(
            id="asst_123",
            content="Assistant response",
            tool_calls=[tool_call]
        )
        serialized = msg.model_dump(by_alias=True)
        self.assertEqual(serialized["role"], "assistant")
        self.assertEqual(serialized["content"], "Assistant response")
        self.assertEqual(len(serialized["toolCalls"]), 1)
        self.assertEqual(serialized["toolCalls"][0]["id"], "call_456")

    def test_user_message(self):
        """Test creating and serializing a user message"""
        msg = UserMessage(
            id="user_123",
            content="User query"
        )
        serialized = msg.model_dump(by_alias=True)
        self.assertEqual(serialized["role"], "user")
        self.assertEqual(serialized["content"], "User query")

    def test_message_union_deserialization(self):
        """Test that the Message union correctly deserializes to the appropriate type"""
        # Create type adapter for the union
        message_adapter = TypeAdapter(Message)

        # Test each message type
        message_data = [
            {"id": "dev_123", "role": "developer", "content": "Developer note"},
            {"id": "sys_456", "role": "system", "content": "System instruction"},
            {"id": "asst_789", "role": "assistant", "content": "Assistant response"},
            {"id": "user_101", "role": "user", "content": "User query"},
            {
                "id": "tool_202", 
                "role": "tool", 
                "content": "Tool result", 
                "toolCallId": "call_303"
            }
        ]

        expected_types = [
            DeveloperMessage,
            SystemMessage,
            AssistantMessage,
            UserMessage,
            ToolMessage
        ]

        for data, expected_type in zip(message_data, expected_types):
            msg = message_adapter.validate_python(data)
            self.assertIsInstance(msg, expected_type)
            self.assertEqual(msg.id, data["id"])
            self.assertEqual(msg.role, data["role"])
            self.assertEqual(msg.content, data["content"])

    def test_message_union_with_tool_calls(self):
        """Test the Message union with an assistant message containing tool calls"""
        # Create type adapter for the union
        message_adapter = TypeAdapter(Message)

        data = {
            "id": "asst_123",
            "role": "assistant",
            "content": "I'll help with that",
            "toolCalls": [
                {
                    "id": "call_456",
                    "type": "function",
                    "function": {
                        "name": "search_data",
                        "arguments": '{"query": "python"}'
                    }
                }
            ]
        }

        msg = message_adapter.validate_python(data)
        self.assertIsInstance(msg, AssistantMessage)
        self.assertEqual(len(msg.tool_calls), 1)
        self.assertEqual(msg.tool_calls[0].function.name, "search_data")

    def test_run_agent_input_deserialization(self):
        """Test deserializing RunAgentInput JSON with diverse message types"""
        # Create JSON data for RunAgentInput with diverse messages
        run_agent_input_data = {
            "threadId": "thread_12345",
            "runId": "run_67890",
            "state": {"conversation_state": "active", "custom_data": {"key": "value"}},
            "messages": [
                # System message
                {
                    "id": "sys_001",
                    "role": "system",
                    "content": "You are a helpful assistant."
                },
                # User message
                {
                    "id": "user_001",
                    "role": "user",
                    "content": "Can you help me analyze this data?"
                },
                # Developer message
                {
                    "id": "dev_001",
                    "role": "developer",
                    "content": "The assistant should provide a detailed analysis."
                },
                # Assistant message with tool calls
                {
                    "id": "asst_001",
                    "role": "assistant",
                    "content": "I'll analyze the data for you.",
                    "toolCalls": [
                        {
                            "id": "call_001",
                            "type": "function",
                            "function": {
                                "name": "analyze_data",
                                "arguments": '{"dataset": "sales_2023", "metrics": ["mean", "median"]}' # pylint: disable=line-too-long
                            }
                        }
                    ]
                },
                # Tool message responding to tool call
                {
                    "id": "tool_001",
                    "role": "tool",
                    "content": '{"mean": 42.5, "median": 38.0}',
                    "toolCallId": "call_001"
                },
                # Another user message
                {
                    "id": "user_002",
                    "role": "user",
                    "content": "Can you explain these results?"
                }
            ],
            "tools": [
                {
                    "name": "analyze_data",
                    "description": "Analyze a dataset and return statistics",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "dataset": {"type": "string"},
                            "metrics": {"type": "array", "items": {"type": "string"}}
                        },
                        "required": ["dataset"]
                    }
                },
                {
                    "name": "fetch_data",
                    "description": "Fetch data from a database",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "source": {"type": "string"},
                            "query": {"type": "string"}
                        },
                        "required": ["source", "query"]
                    }
                }
            ],
            "context": [
                {
                    "description": "User preferences",
                    "value": '{"theme": "dark", "language": "English"}'
                },
                {
                    "description": "Environment",
                    "value": "production"
                }
            ],
            "forwardedProps": {
                "api_version": "v1",
                "custom_settings": {"max_tokens": 500}
            }
        }

        # Deserialize using TypeAdapter
        run_agent_input = RunAgentInput.model_validate(run_agent_input_data)

        # Verify basic fields
        self.assertEqual(run_agent_input.thread_id, "thread_12345")
        self.assertEqual(run_agent_input.run_id, "run_67890")
        self.assertEqual(run_agent_input.state["conversation_state"], "active")

        # Verify messages count and types
        self.assertEqual(len(run_agent_input.messages), 6)
        self.assertIsInstance(run_agent_input.messages[0], SystemMessage)
        self.assertIsInstance(run_agent_input.messages[1], UserMessage)
        self.assertIsInstance(run_agent_input.messages[2], DeveloperMessage)
        self.assertIsInstance(run_agent_input.messages[3], AssistantMessage)
        self.assertIsInstance(run_agent_input.messages[4], ToolMessage)
        self.assertIsInstance(run_agent_input.messages[5], UserMessage)

        # Verify specific message content
        self.assertEqual(run_agent_input.messages[0].content, "You are a helpful assistant.")
        self.assertEqual(run_agent_input.messages[1].content, "Can you help me analyze this data?")

        # Verify assistant message with tool call
        assistant_msg = run_agent_input.messages[3]
        self.assertEqual(len(assistant_msg.tool_calls), 1)
        self.assertEqual(assistant_msg.tool_calls[0].function.name, "analyze_data")

        # Verify tool message
        tool_msg = run_agent_input.messages[4]
        self.assertEqual(tool_msg.tool_call_id, "call_001")
        self.assertEqual(tool_msg.content, '{"mean": 42.5, "median": 38.0}')

        # Verify tools
        self.assertEqual(len(run_agent_input.tools), 2)
        self.assertEqual(run_agent_input.tools[0].name, "analyze_data")
        self.assertEqual(run_agent_input.tools[1].name, "fetch_data")

        # Verify context
        self.assertEqual(len(run_agent_input.context), 2)
        self.assertEqual(run_agent_input.context[0].description, "User preferences")
        self.assertEqual(run_agent_input.context[1].value, "production")

        # Verify forwarded props
        self.assertEqual(run_agent_input.forwarded_props["api_version"], "v1")
        self.assertEqual(run_agent_input.forwarded_props["custom_settings"]["max_tokens"], 500)

    def test_validation_errors(self):
        """Test validation errors for various message types"""
        message_adapter = TypeAdapter(Message)

        # Test invalid role value
        invalid_role_data = {
            "id": "msg_123",
            "role": "invalid_role",  # Invalid role
            "content": "Hello"
        }
        with self.assertRaises(ValidationError):
            message_adapter.validate_python(invalid_role_data)

        # Test missing required fields
        missing_id_data = {
            # Missing "id" field
            "role": "user",
            "content": "Hello"
        }
        with self.assertRaises(ValidationError):
            UserMessage.model_validate(missing_id_data)

        # Test extra fields
        extra_field_data = {
            "id": "msg_456",
            "role": "user",
            "content": "Hello",
            "extra_field": "This shouldn't be here"  # Extra field
        }
        with self.assertRaises(ValidationError):
            UserMessage.model_validate(extra_field_data)

        # Test invalid tool_call_id in ToolMessage
        invalid_tool_data = {
            "id": "tool_789",
            "role": "tool",
            "content": "Result",
            # Missing required tool_call_id
        }
        with self.assertRaises(ValidationError):
            ToolMessage.model_validate(invalid_tool_data)

    def test_empty_collections(self):
        """Test RunAgentInput with empty collections"""
        # Create RunAgentInput with empty lists
        empty_collections_data = {
            "threadId": "thread_empty",
            "runId": "run_empty",
            "state": {},
            "messages": [],  # Empty messages
            "tools": [],     # Empty tools
            "context": [],   # Empty context
            "forwardedProps": {}
        }

        # Deserialize and verify
        run_input = RunAgentInput.model_validate(empty_collections_data)
        self.assertEqual(run_input.thread_id, "thread_empty")
        self.assertEqual(run_input.run_id, "run_empty")
        self.assertEqual(len(run_input.messages), 0)
        self.assertEqual(len(run_input.tools), 0)
        self.assertEqual(len(run_input.context), 0)
        self.assertEqual(run_input.forwarded_props, {})

    def test_multiple_tool_calls(self):
        """Test assistant message with multiple tool calls"""
        # Create assistant message with multiple tool calls
        assistant_data = {
            "id": "asst_multi",
            "role": "assistant",
            "content": "I'll perform multiple operations",
            "toolCalls": [
                {
                    "id": "call_1",
                    "type": "function",
                    "function": {
                        "name": "get_weather",
                        "arguments": '{"location": "New York"}'
                    }
                },
                {
                    "id": "call_2",
                    "type": "function",
                    "function": {
                        "name": "search_database",
                        "arguments": '{"query": "recent sales"}'
                    }
                },
                {
                    "id": "call_3",
                    "type": "function",
                    "function": {
                        "name": "calculate",
                        "arguments": '{"operation": "sum", "values": [1, 2, 3, 4, 5]}'
                    }
                }
            ]
        }

        # Deserialize and verify
        assistant_msg = AssistantMessage.model_validate(assistant_data)
        self.assertEqual(assistant_msg.id, "asst_multi")
        self.assertEqual(len(assistant_msg.tool_calls), 3)

        # Check each tool call
        self.assertEqual(assistant_msg.tool_calls[0].id, "call_1")
        self.assertEqual(assistant_msg.tool_calls[0].function.name, "get_weather")

        self.assertEqual(assistant_msg.tool_calls[1].id, "call_2")
        self.assertEqual(assistant_msg.tool_calls[1].function.name, "search_database")

        self.assertEqual(assistant_msg.tool_calls[2].id, "call_3")
        self.assertEqual(assistant_msg.tool_calls[2].function.name, "calculate")

    def test_serialization_round_trip(self):
        """Test serializing to JSON and deserializing back to verify data integrity"""
        # Create original instance
        original_data = {
            "threadId": "thread_round_trip",
            "runId": "run_round_trip",
            "state": {"status": "active"},
            "messages": [
                {
                    "id": "sys_rt",
                    "role": "system",
                    "content": "You are a helpful assistant."
                },
                {
                    "id": "user_rt",
                    "role": "user",
                    "content": "Help me with my task."
                },
                {
                    "id": "asst_rt",
                    "role": "assistant",
                    "content": "I'll help you.",
                    "toolCalls": [
                        {
                            "id": "call_rt",
                            "type": "function",
                            "function": {
                                "name": "get_task_info",
                                "arguments": "{}"
                            }
                        }
                    ]
                }
            ],
            "tools": [
                {
                    "name": "get_task_info",
                    "description": "Get task information",
                    "parameters": {
                        "type": "object",
                        "properties": {}
                    }
                }
            ],
            "context": [
                {
                    "description": "Session",
                    "value": "123456"
                }
            ],
            "forwardedProps": {
                "timestamp": 1648214400
            }
        }

        # Deserialize
        original_obj = RunAgentInput.model_validate(original_data)

        # Serialize back to JSON
        serialized_json = original_obj.model_dump_json(by_alias=True)

        # Deserialize again
        deserialized_obj = RunAgentInput.model_validate_json(serialized_json)

        # Verify round trip preserved data
        self.assertEqual(deserialized_obj.thread_id, original_obj.thread_id)
        self.assertEqual(deserialized_obj.run_id, original_obj.run_id)
        self.assertEqual(len(deserialized_obj.messages), len(original_obj.messages))

        # Verify message types are preserved
        self.assertIsInstance(deserialized_obj.messages[0], SystemMessage)
        self.assertIsInstance(deserialized_obj.messages[1], UserMessage)
        self.assertIsInstance(deserialized_obj.messages[2], AssistantMessage)

        # Verify tool calls are preserved
        self.assertEqual(len(deserialized_obj.messages[2].tool_calls), 1)
        self.assertEqual(
            deserialized_obj.messages[2].tool_calls[0].function.name,
            original_obj.messages[2].tool_calls[0].function.name
        )

    def test_content_edge_cases(self):
        """Test edge cases for message content"""

        # Test empty content
        empty_content_data = {
            "id": "msg_empty",
            "role": "user",
            "content": ""  # Empty string
        }
        empty_msg = UserMessage.model_validate(empty_content_data)
        self.assertEqual(empty_msg.content, "")

        # Test null content (for assistant messages)
        null_content_data = {
            "id": "asst_null",
            "role": "assistant",
            "content": None,  # Null content
            "toolCalls": [
                {
                    "id": "call_null",
                    "type": "function",
                    "function": {
                        "name": "get_data",
                        "arguments": "{}"
                    }
                }
            ]
        }
        null_msg = AssistantMessage.model_validate(null_content_data)
        self.assertIsNone(null_msg.content)

        # Test large content (not testing for performance, just functionality)
        large_content = "A" * 10000  # 10K characters
        large_content_data = {
            "id": "msg_large",
            "role": "user",
            "content": large_content
        }
        large_msg = UserMessage.model_validate(large_content_data)
        self.assertEqual(len(large_msg.content), 10000)

        # Test content with special characters
        special_chars = "Special chars: ‰Ω†Â•Ω „Åì„Çì„Å´„Å°„ÅØ ÏïàÎÖïÌïòÏÑ∏Ïöî üëã üåç \n\t\"'\\/<>{}[]"
        special_chars_data = {
            "id": "msg_special",
            "role": "user",
            "content": special_chars
        }
        special_msg = UserMessage.model_validate(special_chars_data)
        self.assertEqual(special_msg.content, special_chars)

    def test_name_field_handling(self):
        """Test optional name field in different message types"""
        # Test user message with name
        user_with_name_data = {
            "id": "user_named",
            "role": "user",
            "content": "Hello",
            "name": "John"
        }
        user_msg = UserMessage.model_validate(user_with_name_data)
        self.assertEqual(user_msg.name, "John")

        # Test assistant message with name
        assistant_with_name_data = {
            "id": "asst_named",
            "role": "assistant",
            "content": "Hello",
            "name": "AI Assistant"
        }
        assistant_msg = AssistantMessage.model_validate(assistant_with_name_data)
        self.assertEqual(assistant_msg.name, "AI Assistant")

        # Verify serialization preserves name
        serialized = assistant_msg.model_dump(by_alias=True)
        self.assertEqual(serialized["name"], "AI Assistant")

        # Verify Union type handling with name
        message_adapter = TypeAdapter(Message)
        parsed_msg = message_adapter.validate_python(assistant_with_name_data)
        self.assertEqual(parsed_msg.name, "AI Assistant")

    def test_state_variations(self):
        """Test state with different structures and complex nested objects"""
        # Simple scalar state
        scalar_state_data = {
            "threadId": "thread_scalar",
            "runId": "run_scalar",
            "state": "ACTIVE",  # Scalar state
            "messages": [],
            "tools": [],
            "context": [],
            "forwardedProps": {}
        }
        scalar_input = RunAgentInput.model_validate(scalar_state_data)
        self.assertEqual(scalar_input.state, "ACTIVE")

        # Complex nested state
        complex_state = {
            "session": {
                "id": "sess_123",
                "user": {
                    "id": "user_456",
                    "preferences": {
                        "theme": "dark",
                        "notifications": True,
                        "filters": ["important", "urgent"]
                    }
                },
                "metrics": {
                    "requests": 42,
                    "tokens": {
                        "input": 1024,
                        "output": 2048
                    }
                }
            },
            "timestamp": 1648214400,
            "version": "1.0.0"
        }

        complex_state_data = {
            "threadId": "thread_complex",
            "runId": "run_complex",
            "state": complex_state,
            "messages": [],
            "tools": [],
            "context": [],
            "forwardedProps": {}
        }
        complex_input = RunAgentInput.model_validate(complex_state_data)

        # Verify nested state structure is preserved
        self.assertEqual(complex_input.state["session"]["id"], "sess_123")
        self.assertEqual(complex_input.state["session"]["user"]["id"], "user_456")
        self.assertEqual(complex_input.state["session"]["user"]["preferences"]["theme"], "dark")
        self.assertEqual(complex_input.state["session"]["metrics"]["tokens"]["output"], 2048)
        self.assertEqual(complex_input.state["version"], "1.0.0")

        # Verify serialization round-trip works with complex state
        serialized = complex_input.model_dump(by_alias=True)
        deserialized = RunAgentInput.model_validate(serialized)
        self.assertEqual(
            deserialized.state["session"]["user"]["preferences"]["filters"],
            ["important", "urgent"]
        )


if __name__ == "__main__":
    unittest.main()


